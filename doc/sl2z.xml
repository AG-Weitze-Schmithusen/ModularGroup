<Chapter Label="SL2Z">
<Heading>Subgroups of <M>SL_2(&ZZ;)</M></Heading>

For representing finite-index subgroups of <M>SL_2(&ZZ;)</M>, this package
introduces the new type <C>ModularSubgroup</C>. As stated in the introduction,
a <C>ModularSubgroup</C> essentially consists of the two permutations
<M>\sigma_S</M> and <M>\sigma_T</M> describing the coset graph with respect
to the generator matrices <M>S</M> and <M>T</M> (with the convention that <M>1</M>
corresponds to the identity coset). So explicitly specifying these permutations
is the canonical way to construct a <C>ModularSubgroup</C>. <Br/>
Though you might not always have a coset graph of your subgroup at hand, but
rather a list of generator matrices. Therefore we implement two different
constructors for <C>ModularSubgroup</C>, one that takes as input two permutations
describing the coset graph, and one that takes a list of <M>SL_2(&ZZ;)</M>
matrices as generators.

<Section Label="ModularSubgroupConstr">
<Heading>Construction of modular subgroups</Heading>

<ManSection>
  <Heading>Constructors</Heading>

  <Oper Name="ModularSubgroup" Arg="s, t" />
  <Returns>A modular subgroup.</Returns>
  <Description>
    Constructs a <C>ModularSubgroup</C> object corresponding to the finite-index
    subgroup of <M>SL_2(&ZZ;)</M> described by the permutations <A>s</A> and
    <A>t</A>. <Br/>
    This constructor tests if the given permutations actually describe the
    coset action of the matrices
    <Alt Only="LaTeX">
      <![CDATA[
      \[
            S =
            \left(
               \begin{array}{rr}
                  0 & -1 \\
                  1 & 0
               \end{array}
            \right)
            \quad
            T =
            \left(
               \begin{array}{rr}
                  1 & 1 \\
                  0 & 1
               \end{array}
            \right)
      \]
      ]]>
    </Alt>
    <Alt Only="Text,HTML"><Verb><![CDATA[
                     [ 0 -1 ]           [ 1  1 ]
                 S = [ 1  0 ]       T = [ 0  1 ]
    ]]></Verb></Alt>
    by checking that they act transitively and satisfy the relations
    <Display>s^4 = (s^3 t)^3 = s^2 t s^{-2} t^{-1} = 1</Display>

    Upon creation, the cosets are renamed in a <URL Text="standardized fashion">https://www.gap-system.org/Manuals/doc/ref/chap47.html#X85B882F782D7AFD0</URL>
    to make the internal interaction with extisting &GAP; methods easier.

    <Example>
    <![CDATA[
    gap> G := ModularSubgroup(
    > (1,2)(3,4)(5,6)(7,8)(9,10),
    > (1,4)(2,5,9,10,8)(3,7,6));
    <modular subgroup of index 10>
    ]]>
  </Example>
  </Description>

  <Oper Name="ModularSubgroup" Arg="gens" />
  <Returns>A modular subgroup.</Returns>
  <Description>
    Constructs a <C>ModularSubgroup</C> object corresponding to the finite-index
    subgroup of <M>SL_2(&ZZ;)</M> generated by the matrices in <A>gens</A>. <Br/>
    No test is performed to check if the generated subgroup actually has finite
    index! <Br/>
    This constructor implicitly computes a coset table of the subgroup. Hence it
    might be slow for very large index subgroups.

    <Example>
    <![CDATA[
    gap> G := ModularSubgroup([
    > [[1,2], [0,1]],
    > [[1,0], [2,1]],
    > [[-1,0], [0,-1]]
    > ]);
    <modular subgroup of index 6>
    ]]>
  </Example>
  </Description>

</ManSection>

<ManSection>
  <Heading>Getters for the coset action</Heading>

  <Oper Name="SAction" Arg="G" />
  <Returns>A permutation.</Returns>
  <Description>
    Returns the permutation <M>\sigma_S</M> describing the action of the matrix
    <M>S</M> on the cosets of <A>G</A>.
  </Description>

  <Oper Name="TAction" Arg="G" />
  <Returns>A permutation.</Returns>
  <Description>
    Returns the permutation <M>\sigma_T</M> describing the action of the matrix
    <M>T</M> on the cosets of <A>G</A>.
  </Description>

  <Oper Name="CosetActionOf" Arg="A, G" />
  <Returns>A permutation.</Returns>
  <Description>
    Returns the permutation <M>\sigma_A</M> describing the action of the matrix
    <M>A \in SL_2(&ZZ;)</M> on the cosets of <A>G</A>.
  </Description>

</ManSection>
</Section>

<Section Label="ModularSubgroupAlgs">
<Heading>Computing with modular subgroups</Heading>

<ManSection>
  <Attr Name="Index" Arg="G" />
  <Returns>A natural number.</Returns>
  <Description>
    For a given modular subgroup <A>G</A> this method returns its index in
    <M>SL_2(&ZZ;)</M>. As <A>G</A> is internally stored as permutations
    <M>(s,t)</M> this is just
    <Verb>
      LargestMovedPoint(s,t)
    </Verb>
    (or <M>1</M> if the permutations are trivial).
  </Description>
</ManSection>

<ManSection>
  <Attr Name="GeneralizedLevel" Arg="G" />
  <Returns>A natural number.</Returns>
  <Description>
    This method calculates the general Wohlfahrt level (i.e. the lowest common
    multiple of all cusp widths) of <A>G</A>.
  </Description>
</ManSection>

<ManSection>
  <Attr Name="RightCosetRepresentatives" Arg="G" />
  <Returns>A list of words.</Returns>
  <Description>
    This function returns a list of representatives of the (right) cosets of
    <A>G</A> as words in <M>S</M> and <M>T</M>.
  </Description>
</ManSection>
<Example>
  <![CDATA[
  gap> G := ModularSubgroup((1,2),(2,3));
  <modular subgroup of index 3>
  gap> RightCosetRepresentatives(G);
  [ <identity ...>, S, S*T ]
  ]]>
</Example>

<ManSection>
  <Attr Name="GeneratorsOfGroup" Arg="G" />
  <Returns>A list of words.</Returns>
  <Description>
    Calculates a list of generators (as words in <M>S</M> and <M>T</M>) of <A>G</A>.
    This list might include redundant generators (or even duplicates).
  </Description>
</ManSection>
<Example>
  <![CDATA[
  gap> G := ModularSubgroup((1,2)(3,5)(4,6), (1,3)(2,4)(5,6));
  <modular subgroup of index 6>
  gap> GeneratorsOfGroup(G);
  [ S^-2, T^-2, S*T^-2*S^-1 ]
  ]]>
</Example>

<ManSection>
  <Attr Name="MatrixGeneratorsOfGroup" Arg="G" />
  <Returns>A list of matrices.</Returns>
  <Description>
    Calculates a list of generator matrices of <A>G</A>.
    This list might include redundant generators (or even duplicates).
  </Description>
</ManSection>
<Example>
  <![CDATA[
  gap> G := ModularSubgroup((1,2)(3,5)(4,6), (1,3)(2,4)(5,6));
  <modular subgroup of index 6>
  gap> MatrixGeneratorsOfGroup(G);
  [ [ [ -1, 0 ], [ 0, -1 ] ], [ [ 1, -2 ], [ 0, 1 ] ], [ [ 1, 0 ], [ 2, 1 ] ] ]
  ]]>
</Example>

<ManSection>
  <Attr Name="IsCongruenceSubgroup" Arg="G" />
  <Returns>True or false.</Returns>
  <Description>
    This method test whether a given modular subgroup <A>G</A> is a congruence
    subgroup. It is essentially an implementation of an algorithm described in
    <Cite Key="hamilton_loeffler_2014"/>.
  </Description>
</ManSection>
<Example>
  <![CDATA[
  gap> G := ModularSubgroup([
  > [[1,2],[0,1]],
  > [[1,0],[2,1]]
  > ]);
  <modular subgroup of index 12>
  gap> IsCongruenceSubgroup(G);
  true
  ]]>
</Example>

<ManSection>
  <Attr Name="Cusps" Arg="G" />
  <Returns>A list of rational numbers and infinity.</Returns>
  <Description>
    This method computes a list of inequivalent cusp representatives with respect
    to <A>G</A>.
  </Description>
</ManSection>
<Example>
  <![CDATA[
  gap> G := ModularSubgroup(
  > (1,2)(3,6)(4,8)(5,9)(7,11)(10,13)(12,15)(14,17)(16,19)(18,21)(20,23)(22,24),
  > (1,3,7,4)(2,5)(6,9,8,12,14,10)(11,13,16,20,18,15)(17,21,22,19)(23,24)
  > );
  <modular subgroup of index 24>
  gap> Cusps(G);
  [ infinity, 0, 1, 2, 3/2, 5/3 ]
  ]]>
</Example>

<ManSection>
  <Oper Name="CuspWidth" Arg="c, G" />
  <Returns>A natural number.</Returns>
  <Description>
    This method takes as input a cusp <A>c</A> (a rational number or infinity)
    and a modular group <A>G</A> and calculates the width of this cusp with
    respect to <A>G</A>.
  </Description>
</ManSection>
<Example>
  <![CDATA[
  gap> G := ModularSubgroup(
  > (1,2,6,3)(4,11,15,12)(5,13,16,14)(7,17,9,18)(8,19,10,20)(21,24,22,23),
  > (1,4,5)(2,7,8)(3,9,10)(6,15,16)(11,20,21)(12,19,22)(13,23,17)(14,24,18)
  > );
  <modular subgroup of index 24>
  gap> CuspWidth(-1, G);
  3
  gap> CuspWidth(infinity, G);
  3
  ]]>
</Example>

<ManSection>
  <Oper Name="CuspsEquivalent" Arg="p, q, G" />
  <Returns>True or false.</Returns>
  <Description>
    Takes two cusps <A>p</A> and <A>q</A> and a modular subgroup <A>G</A> and
    checks if they are equivalent modulo <A>G</A>, i.e. if there exists a matrix
    <M>A \in G</M> with <M>Ap = q</M>.
  </Description>
</ManSection>
<Example>
  <![CDATA[
  gap> G := ModularSubgroup(
  > (1,2,6,3)(4,11,15,12)(5,13,16,14)(7,17,9,18)(8,19,10,20)(21,24,22,23),
  > (1,4,5)(2,7,8)(3,9,10)(6,15,16)(11,20,21)(12,19,22)(13,23,17)(14,24,18)
  > );
  <modular subgroup of index 24>
  gap> CuspsEquivalent(infinity, 1, G);
  false
  gap> CuspsEquivalent(-1, 1/2, G);
  true
  ]]>
</Example>

<ManSection>
  <Oper Name="IndexModN" Arg="G, N" />
  <Returns>A natural number.</Returns>
  <Description>
    For a modular subgroup <A>G</A> and a natural number <A>N</A> this method
    calculates the index of the projection <M>\bar{G}</M> of <M>G</M> in
    <M>SL_2(&ZZ;/N&ZZ;)</M>.
  </Description>
</ManSection>

<ManSection>
  <Oper Name="Deficiency" Arg="G, N" />
  <Returns>A natural number.</Returns>
  <Description>
    For a modular subgroup <A>G</A> and a natural number <A>N</A> this method
    calculates the so-called <Emph>deficiency</Emph> of <A>G</A> from being a
    congruence subgroup of level <A>N</A>. <Br/>
    The deficiency of a finite-index subgroup <M>\Gamma</M> of <M>SL_2(&ZZ;)</M>
    was introduced in <Cite Key="weitze_schmithuesen_deficiency" />. It is defined
    as the index <M>[\Gamma(N) \colon \Gamma(N) \cap \Gamma]</M> where <M>\Gamma(N)</M>
    is the principal congruence subgroup of level <M>N</M>.
  </Description>
</ManSection>
<Example>
  <![CDATA[
  gap> G := ModularSubgroup([
  > [[1,2],[0,1]],
  > [[1,0],[2,1]]
  > ]);
  <modular subgroup of index 12>
  gap> Deficiency(G, 2);
  2
  gap> Deficiency(G, 4);
  1
  ]]>
</Example>

<ManSection>
  <Oper Name="Projection" Arg="G" />
  <Returns>A projective modular subgroup.</Returns>
  <Description>
    For a given modular subgroup <A>G</A> this function calculates its image
    <M>\bar{<A>G</A>}</M> under the projection <M>\pi \colon SL_2(&ZZ;) \rightarrow PSL_2(&ZZ;)</M>.
  </Description>
</ManSection>

<ManSection>
  <Oper Name="NormalCore" Arg="G" />
  <Returns>A modular subgroup.</Returns>
  <Description>
    Calculates the normal core of <A>G</A> in <M>SL_2(&ZZ;)</M>, i.e. the maximal
    subgroup of <A>G</A> that is normal in <M>SL_2(&ZZ;)</M>.
  </Description>
</ManSection>

<ManSection>
  <Oper Name="IsElementOf" Arg="A, G" />
  <Returns>True or false.</Returns>
  <Description>
    This function checks if a given matrix <A>A</A> is an element of the modular
    subgroup <A>G</A>.
  </Description>
</ManSection>

</Section>

<Section Label="ModularSubgroupMisc">
<Heading>Miscellaneous</Heading>

The following functions are mostly helper functions used internally and are only
documented for sake of completeness.

<ManSection>
  <Oper Name="DefinesCosetAction" Arg="s, t" />
  <Returns>True or false.</Returns>
  <Description>
    Checks if two given permutations <A>s</A> and <A>t</A> describe
    the action of the generator matrices <M>S</M> and <M>T</M> on the cosets of
    some subgroup. This is the case if they satisfy the relations
    <Display>s^4 = (s^3 t)^3 = s^2 t s^{-2} t^{-1} = 1</Display>
    and act transitively.
  </Description>
</ManSection>

<ManSection>
  <Oper Name="CosetActionFromGenerators" Arg="gens" />
  <Returns>A tuple of permutations.</Returns>
  <Description>
    Takes a list of generator matrices and calculates the coset graph (as two
    permutations <M>\sigma_S</M> and <M>\sigma_T</M>) of the generated subgroup
    of <M>SL_2(&ZZ;)</M>.
  </Description>
</ManSection>

<ManSection>
  <Oper Name="STDecomposition" Arg="A" />
  <Returns>A word in <M>S</M> and <M>T</M>.</Returns>
  <Description>
    Takes a matrix <M><A>A</A> \in SL_2(&ZZ;)</M> and decomposes it into a word
    in the generator matrices <M>S</M> and <M>T</M>.
  </Description>
</ManSection>


</Section>

</Chapter>
