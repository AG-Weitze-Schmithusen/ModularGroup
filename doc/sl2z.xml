<Chapter Label="SL2Z">
<Heading>Subgroups of <M>SL_2(&ZZ;)</M></Heading>

For representing finite-index subgroups of <M>SL_2(&ZZ;)</M>, this package
introduces the new type <C>ModularSubgroup</C>. As stated in the introduction,
a <C>ModularSubgroup</C> essentially consists of the two permutations
<M>\sigma_S</M> and <M>\sigma_T</M> describing the coset graph with respect
to the generator matrices <M>S</M> and <M>T</M> (with the convention that <M>1</M>
corresponds to the identity coset). So explicitly specifying these permutations
is the canonical way to construct a <C>ModularSubgroup</C>. <Br/>
Though you might not always have a coset graph of your subgroup at hand, but
rather a list of generator matrices. Therefore we implement two different
constructors for <C>ModularSubgroup</C>, one that takes as input two permutations
describing the coset graph, and one that takes a list of <M>SL_2(&ZZ;)</M>
matrices as generators.

<Section Label="ModularSubgroupConstr">
<Heading>Construction of modular subgroups</Heading>

<ManSection>
  <Heading>Constructors</Heading>

  <Oper Name="ModularSubgroup" Arg="s, t" />
  <Returns>A modular subgroup.</Returns>
  <Description>
    Constructs a <C>ModularSubgroup</C> object corresponding to the finite-index
    subgroup of <M>SL_2(&ZZ;)</M> described by the permutations <A>s</A> and
    <A>t</A>. <Br/>
    This constructor tests if the given permutations actually describe the
    coset action of the matrices
    <Alt Only="LaTeX">
      <![CDATA[
      \[
            S =
            \left(
               \begin{array}{rr}
                  0 & -1 \\
                  1 & 0
               \end{array}
            \right)
            \quad
            T =
            \left(
               \begin{array}{rr}
                  1 & 1 \\
                  0 & 1
               \end{array}
            \right)
      \]
      ]]>
    </Alt>
    <Alt Only="Text,HTML"><Verb><![CDATA[
                     [ 0 -1 ]           [ 1  1 ]
                 S = [ 1  0 ]       T = [ 0  1 ]
    ]]></Verb></Alt>
    by checking that they act transitively and satisfy the relations
    <Display>s^4 = (s^3 t)^3 = s^2 t s^{-2} t^{-1} = 1</Display>

    Upon creation, the cosets are renamed in a <URL Text="standardized fashion">https://www.gap-system.org/Manuals/doc/ref/chap47.html#X85B882F782D7AFD0</URL>
    to make the internal interaction with extisting &GAP; methods easier.

    <Example>
    <![CDATA[
    gap> G := ModularSubgroup(
    > (1,2)(3,4)(5,6)(7,8)(9,10),
    > (1,4)(2,5,9,10,8)(3,7,6));
    <modular subgroup of index 10>
    ]]>
  </Example>
  </Description>

  <Oper Name="ModularSubgroup" Arg="gens" />
  <Returns>A modular subgroup.</Returns>
  <Description>
    Constructs a <C>ModularSubgroup</C> object corresponding to the finite-index
    subgroup of <M>SL_2(&ZZ;)</M> generated by the matrices in <A>gens</A>. <Br/>
    No test is performed to check if the generated subgroup actually has finite
    index! <Br/>
    This constructor implicitly computes a coset table of the subgroup. Hence it
    might be slow for very large index subgroups.

    <Example>
    <![CDATA[
    gap> G := ModularSubgroup([
    > [[1,2], [0,1]],
    > [[1,0], [2,1]],
    > [[-1,0], [0,-1]]
    > ]);
    <modular subgroup of index 6>
    ]]>
  </Example>
  </Description>

</ManSection>

<ManSection>
  <Heading>Getters for the coset action</Heading>

  <Oper Name="SAction" Arg="G" />
  <Returns>A permutation.</Returns>
  <Description>
    Returns the permutation <M>\sigma_S</M> describing the action of the matrix
    <M>S</M> on the cosets of <A>G</A>.
  </Description>

  <Oper Name="TAction" Arg="G" />
  <Returns>A permutation.</Returns>
  <Description>
    Returns the permutation <M>\sigma_T</M> describing the action of the matrix
    <M>T</M> on the cosets of <A>G</A>.
  </Description>

  <Oper Name="CosetActionOf" Arg="A, G" />
  <Returns>A permutation.</Returns>
  <Description>
    Returns the permutation <M>\sigma_A</M> describing the action of the matrix
    <M>A \in SL_2(&ZZ;)</M> on the cosets of <A>G</A>.
  </Description>

</ManSection>
</Section>

<Section Label="ModularSubgroupAlgs">
<Heading>Computing with modular subgroups</Heading>

<ManSection>
  <Attr Name="Index" Arg="G" />
  <Returns>A natural number.</Returns>
  <Description>
    For a given modular subgroup <A>G</A> this method returns its index in
    <M>SL_2(&ZZ;)</M>. As <A>G</A> is internally stored as permutations
    <M>(s,t)</M> this is just
    <Verb>
      LargestMovedPoint(s,t)
    </Verb>
    (or <M>1</M> if the permutations are trivial).
  </Description>
</ManSection>

<ManSection>
  <Attr Name="GeneralizedLevel" Arg="G" />
  <Returns>A natural number.</Returns>
  <Description>
    This method calculates the general Wohlfahrt level (i.e. the lowest common
    multiple of all cusp widths) of <A>G</A>.
  </Description>
</ManSection>

<ManSection>
  <Attr Name="RightCosetRepresentatives" Arg="G" />
  <Returns>A list of words.</Returns>
  <Description>
    This function returns a list of representatives of the (right) cosets of
    <A>G</A> as words in <M>S</M> and <M>T</M>.
  </Description>
</ManSection>
<Example>
  <![CDATA[
  gap> G := ModularSubgroup((1,2),(2,3));
  <modular subgroup of index 3>
  gap> RightCosetRepresentatives(G);
  [ <identity ...>, S, S*T ]
  ]]>
</Example>

<ManSection>
  <Attr Name="GeneratorsOfGroup" Arg="G" />
  <Returns>A list of words.</Returns>
  <Description>
    Calculates a list of generators (as words in <M>S</M> and <M>T</M>) of <A>G</A>.
    This list might include redundant generators (or even duplicates).
  </Description>
</ManSection>
<Example>
  <![CDATA[
  gap> G := ModularSubgroup((1,2)(3,5)(4,6), (1,3)(2,4)(5,6));
  <modular subgroup of index 6>
  gap> GeneratorsOfGroup(G);
  [ S^-2, T^-2, S*T^-2*S^-1 ]
  ]]>
</Example>

<ManSection>
  <Attr Name="MatrixGeneratorsOfGroup" Arg="G" />
  <Returns>A list of matrices.</Returns>
  <Description>
    Calculates a list of generator matrices of <A>G</A>.
    This list might include redundant generators (or even duplicates).
  </Description>
</ManSection>
<Example>
  <![CDATA[
  gap> G := ModularSubgroup((1,2)(3,5)(4,6), (1,3)(2,4)(5,6));
  <modular subgroup of index 6>
  gap> MatrixGeneratorsOfGroup(G);
  [ [ [ -1, 0 ], [ 0, -1 ] ], [ [ 1, -2 ], [ 0, 1 ] ], [ [ 1, 0 ], [ 2, 1 ] ] ]
  ]]>
</Example>

<ManSection>
  <Attr Name="IsCongruenceSubgroup" Arg="G" />
  <Returns>True or false.</Returns>
  <Description>
    This method test whether a given modular subgroup <A>G</A> is a congruence
    subgroup. It is essentially an implementation of an algorithm described in
    <Cite Key="hamilton_loeffler_2014"/>.
  </Description>
</ManSection>
<Example>
  <![CDATA[
  gap> G := ModularSubgroup([
  > [[1,2],[0,1]],
  > [[1,0],[2,1]]
  > ]);
  <modular subgroup of index 12>
  gap> IsCongruenceSubgroup(G);
  true
  ]]>
</Example>

<ManSection>
  <Attr Name="Cusps" Arg="G" />
  <Returns>A list of rational numbers and infinity.</Returns>
  <Description>
    This method computes a list of inequivalent cusp representatives with respect
    to <A>G</A>.
  </Description>
</ManSection>
<Example>
  <![CDATA[
  gap> G := ModularSubgroup(
  > (1,2)(3,6)(4,8)(5,9)(7,11)(10,13)(12,15)(14,17)(16,19)(18,21)(20,23)(22,24),
  > (1,3,7,4)(2,5)(6,9,8,12,14,10)(11,13,16,20,18,15)(17,21,22,19)(23,24)
  > ]);
  <modular subgroup of index 24>
  gap> Cusps(G);
  [ infinity, 0, 1, 2, 3/2, 5/3 ]
  ]]>
</Example>



</Section>

</Chapter>
